After finishing workshop 1, I’ve learned how to use #ifndef, #define in a header file to guard a class definition from duplication, make a variable accessible in a different translation unit by using the extern keyword, declare a local variable resides in memory throughout the lifetime of the program using the keyword static, allow the application to accept program arguments (int main(int argc, char **argv), the first parameter represents the total number of arguments, the second parameter represents an array of argument strings) from command line, and allow a class to accept user-defined strings of any length.

A name with external linkage refers to an entity that’s declared in a different scope within another unit while a name with internal linkage refers to an entity that is invisible outside its own translation unit, but visible to other scopes within its translation unit. For example, in Module Event, extern unsigned g_sysClock refers to the same entity and can be accessed across event.cpp and w1_p1.cpp. static size_t counter is visible to function display() but only within the event.cpp unit, it keeps track of how many times function has been called as it increments by 1 every time (++counter). 

To make our application more robust and flexible, I upgraded the data member desc from Event class to be a dynamic allocated c string which is a resource. Because of this change in our code, I also needed to explicitly define the copy constructor Event(const Event& copy), copy assignment operator Event& operator=(const Event& e), and destructor ~Event() to handle both memory allocation and deallocation of char *desc according to the rule of three. 
